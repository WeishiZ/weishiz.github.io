<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Java Nested Class - (Original Post: Usage of java keyword “final” in Android) | Your awesome title</title>
<meta name="generator" content="Jekyll v3.8.0" />
<meta property="og:title" content="Java Nested Class - (Original Post: Usage of java keyword “final” in Android)" />
<meta name="author" content="Weishi Zeng" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Java Nested Classclass OuterClass { ... static class StaticNestedClass { ... } class InnerClass { ... }}1. Static Nested ClassIntuition:Just like a top level class, nested for packaging convenience.Constructor:OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can only direct access outer class static members. (Like any other class accessing OuterClass.java)&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can define both static/non-static members. (members: fields + methods.)Usage://like top-level class, more power to define, less power to accessstatic class StaticNestedClass { private Integer instanceField = 1; private static String staticField = outer_static_field; public static void staticMethod() { String a = outer_static_field; } public void instanceMethod() { String a = outer_static_field; //String b = outer_instance_field; //ERROR: cannot reference non-static field }}2. Inner ClassIntuition:Like a instance member, &quot;belongs to&quot; an outer class instance.Constructor:OuterClass.InnerClass innerObject = outerObject.new InnerClass();Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class.&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. Since it is associated with an instance.Usage://Like a instance member, &quot;belongs to&quot; an outer class instance.class InnerClass { private String inner_instance_field = &quot;inner_instance_field&quot;; public InnerClass () {} public void get_outer_member () { //can access any outer member String a = outer_static_field; String b = outer_private_static_method(); String c = outer_instance_field; inner_instance_field = &quot;&quot;; } //COMPILE ERROR: no static member allowed //public interface inner_interface {}; //an interface is an effective static member //public static String get_static_instance_field () {} //private static String static_field = &quot;static_field&quot;;}2.1. Local ClassIntuition:Defined inside a block (a method, a if block, a for loop). The scope of the class is its enclosing block. A special case of inner class. Thus no static member, a rule inherited from inner class.Constructor: Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;But for local classes in static contexts, can only refer to static members of the enclosing class. &quot;Non-static member cannot be referenced from a static context&quot; this rule always applies.&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. EVEN IF it&#39;s inside a static block.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. A local class can have static members provided that they are constant variables.(A constant variable is a variable of primitive type or type String that is declaredfinal and initialized with a compile-time constant expression.A compile-time constant expression is typically a string or an arithmetic expressionthat can be evaluated at compile time.Note: If a primitive type or a string is defined as a constant and the value is known atcompile time, the compiler replaces the constant name everywhere in the code with its value.This is called a compile-time constant. If the value of the constant in the outside world changes(for example, if it is legislated that pi actually should be 3.975),you will need to recompile any classes that use this constant to get the current value.&nbsp; &nbsp; Local Variable Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final. A local class can use the local variables, method parameters, and even exception parameters that are in its scope, but only if those variables or parameters are declared final. This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined. For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler). The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final.Usage: { class LocalClass { //can access outer member String a = outer_instance_field; String b = outer_static_field; //static String c = &quot;&quot;; //ERROR: no static allowed //final static String d ; //ERROR: not a compile-time constant final static String d = &quot;&quot;; //a constant known at compile time } //static class StaticLocalClass {} //ERROR: local class cannot be static, regardless where.}static { //this is a static context //static class StaticLocalClass {} //ERROR: local class cannot be static, even if in static context class LocalClass { //can access outer member //String a = outer_instance_field; //ERROR: non-static cannot be referenced from static context String b = outer_static_field; //static String c = &quot;&quot;; //ERROR: no static allowed //final static String d ; //ERROR: not a compile-time constant final static String d = &quot;&quot;; //a constant known at compile time }}public void outer_instance_method(Object method_param) { String outer_instance_method_local_var = &quot;&quot;; class LocalClass { //local class at non-static context String f = &quot;&quot;; //can have non-static member /* A local class can have static members provided that they are constant variables. (A constant variable is a variable of primitive type or type String that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. Note: If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value. */ //final static Object d = new NestedClassTest(); //ERROR: this is not a compile time constant final static int e = 5; //need to be string or int. need to know it at compile time String a = outer_instance_field; String b = outer_static_field; String c = outer_instance_method_local_var; //outer_instance_method_local_var need to be final Object abc = method_param; //can access final method param private void local_method() { Object d = method_param; //can access final method param //outer_instance_method_local_var = &quot;&quot;; //ERROR: need to be final //method_param = &quot;&quot;; //ERROR: need to be final outer_instance_field = &quot;&quot;; //no problem interact with outer class field outer_static_field = &quot;&quot;; //can access static or non-static LocalClass a = new LocalClass(); } } //a local class is valid only within the scope defined by its enclosing block. //But the local class has access to outer class members. LocalClass a = new LocalClass(); /* A local class can use the local variables, method parameters, and even exception parameters that are in its scope, but only if those variables or parameters are declared final. This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined. For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler). The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final. */ outer_static_field2 = a; //here, a local class instance outlives local method scope a.local_method();}2.2. Anonymous ClassIntuition:&nbsp;&nbsp;Local class without a name.Constructor://implementing interfacenew InterfacName () { /*class-body*/ }//extending classnew ClassName ( [ argument-list ] ) { /*class-body*/ }Consequences: &nbsp; &nbsp;&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like local class. &nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. &nbsp; &nbsp; Local Variable Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final. Usage: class Executor {public static void execute(Runnable r){r.run();r.run2();}}class BaseTracker {public void track(Object obj){}}interface Runnable { void run(); //abstract method default void run2(){}; //extension method}class Tracker extends BaseTracker{ private String outer_class_var = &quot;&quot;; //anonymous class public void track1(final Object event) { Executor.execute(new Runnable() { //static String a = &quot;&quot;; //ERROR: no static allowed final static String b = &quot;&quot;; //constant OK String c = outer_class_var; //compiler create a package-level getter for enclosing class&#39;s private variables @Override public void run() { Tracker.super.track(event); //Tracker.super refers to enclosing class&#39;s super class //super.track(event); //ERROR: cannot resolve //BaseTracker.track(event); //ERROR: can only reference static method } }); } //local class public void track2(final Object event) { //anonymous class translated into local class class TrackerRunnable implements Runnable { //@Override public void run(){ //super need to be in a non-static context System.out.println(this.toString()); //this refers to the TrackerRunnable instance System.out.println(super.toString()); //super defaults to the same instance!!! Tracker.super.track(event); //Tracker.super refers to BaseTracker Runnable.super.run2(); //Runnable.super refers to Runnable //super.track(event); //ERROR: cannot resolve, super refers to this //BaseTracker.track(event); //ERROR: can only reference static method, .track() is instance method } } Executor.execute(new TrackerRunnable()); } public static void main(String... args) { new Tracker().track2(&quot;&quot;); }}Reference: Java in a Nutshell: How Inner Classes WorkTODO: final keyword:1. class - cannot be subclassed2. method - cannot be overridden3. variable - cannot be assigned more than onceJava memory model: stack, heap,synthetic copydp/dip 是个长度单位。" />
<meta property="og:description" content="Java Nested Classclass OuterClass { ... static class StaticNestedClass { ... } class InnerClass { ... }}1. Static Nested ClassIntuition:Just like a top level class, nested for packaging convenience.Constructor:OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can only direct access outer class static members. (Like any other class accessing OuterClass.java)&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can define both static/non-static members. (members: fields + methods.)Usage://like top-level class, more power to define, less power to accessstatic class StaticNestedClass { private Integer instanceField = 1; private static String staticField = outer_static_field; public static void staticMethod() { String a = outer_static_field; } public void instanceMethod() { String a = outer_static_field; //String b = outer_instance_field; //ERROR: cannot reference non-static field }}2. Inner ClassIntuition:Like a instance member, &quot;belongs to&quot; an outer class instance.Constructor:OuterClass.InnerClass innerObject = outerObject.new InnerClass();Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class.&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. Since it is associated with an instance.Usage://Like a instance member, &quot;belongs to&quot; an outer class instance.class InnerClass { private String inner_instance_field = &quot;inner_instance_field&quot;; public InnerClass () {} public void get_outer_member () { //can access any outer member String a = outer_static_field; String b = outer_private_static_method(); String c = outer_instance_field; inner_instance_field = &quot;&quot;; } //COMPILE ERROR: no static member allowed //public interface inner_interface {}; //an interface is an effective static member //public static String get_static_instance_field () {} //private static String static_field = &quot;static_field&quot;;}2.1. Local ClassIntuition:Defined inside a block (a method, a if block, a for loop). The scope of the class is its enclosing block. A special case of inner class. Thus no static member, a rule inherited from inner class.Constructor: Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;But for local classes in static contexts, can only refer to static members of the enclosing class. &quot;Non-static member cannot be referenced from a static context&quot; this rule always applies.&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. EVEN IF it&#39;s inside a static block.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. A local class can have static members provided that they are constant variables.(A constant variable is a variable of primitive type or type String that is declaredfinal and initialized with a compile-time constant expression.A compile-time constant expression is typically a string or an arithmetic expressionthat can be evaluated at compile time.Note: If a primitive type or a string is defined as a constant and the value is known atcompile time, the compiler replaces the constant name everywhere in the code with its value.This is called a compile-time constant. If the value of the constant in the outside world changes(for example, if it is legislated that pi actually should be 3.975),you will need to recompile any classes that use this constant to get the current value.&nbsp; &nbsp; Local Variable Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final. A local class can use the local variables, method parameters, and even exception parameters that are in its scope, but only if those variables or parameters are declared final. This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined. For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler). The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final.Usage: { class LocalClass { //can access outer member String a = outer_instance_field; String b = outer_static_field; //static String c = &quot;&quot;; //ERROR: no static allowed //final static String d ; //ERROR: not a compile-time constant final static String d = &quot;&quot;; //a constant known at compile time } //static class StaticLocalClass {} //ERROR: local class cannot be static, regardless where.}static { //this is a static context //static class StaticLocalClass {} //ERROR: local class cannot be static, even if in static context class LocalClass { //can access outer member //String a = outer_instance_field; //ERROR: non-static cannot be referenced from static context String b = outer_static_field; //static String c = &quot;&quot;; //ERROR: no static allowed //final static String d ; //ERROR: not a compile-time constant final static String d = &quot;&quot;; //a constant known at compile time }}public void outer_instance_method(Object method_param) { String outer_instance_method_local_var = &quot;&quot;; class LocalClass { //local class at non-static context String f = &quot;&quot;; //can have non-static member /* A local class can have static members provided that they are constant variables. (A constant variable is a variable of primitive type or type String that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. Note: If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value. */ //final static Object d = new NestedClassTest(); //ERROR: this is not a compile time constant final static int e = 5; //need to be string or int. need to know it at compile time String a = outer_instance_field; String b = outer_static_field; String c = outer_instance_method_local_var; //outer_instance_method_local_var need to be final Object abc = method_param; //can access final method param private void local_method() { Object d = method_param; //can access final method param //outer_instance_method_local_var = &quot;&quot;; //ERROR: need to be final //method_param = &quot;&quot;; //ERROR: need to be final outer_instance_field = &quot;&quot;; //no problem interact with outer class field outer_static_field = &quot;&quot;; //can access static or non-static LocalClass a = new LocalClass(); } } //a local class is valid only within the scope defined by its enclosing block. //But the local class has access to outer class members. LocalClass a = new LocalClass(); /* A local class can use the local variables, method parameters, and even exception parameters that are in its scope, but only if those variables or parameters are declared final. This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined. For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler). The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final. */ outer_static_field2 = a; //here, a local class instance outlives local method scope a.local_method();}2.2. Anonymous ClassIntuition:&nbsp;&nbsp;Local class without a name.Constructor://implementing interfacenew InterfacName () { /*class-body*/ }//extending classnew ClassName ( [ argument-list ] ) { /*class-body*/ }Consequences: &nbsp; &nbsp;&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like local class. &nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. &nbsp; &nbsp; Local Variable Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final. Usage: class Executor {public static void execute(Runnable r){r.run();r.run2();}}class BaseTracker {public void track(Object obj){}}interface Runnable { void run(); //abstract method default void run2(){}; //extension method}class Tracker extends BaseTracker{ private String outer_class_var = &quot;&quot;; //anonymous class public void track1(final Object event) { Executor.execute(new Runnable() { //static String a = &quot;&quot;; //ERROR: no static allowed final static String b = &quot;&quot;; //constant OK String c = outer_class_var; //compiler create a package-level getter for enclosing class&#39;s private variables @Override public void run() { Tracker.super.track(event); //Tracker.super refers to enclosing class&#39;s super class //super.track(event); //ERROR: cannot resolve //BaseTracker.track(event); //ERROR: can only reference static method } }); } //local class public void track2(final Object event) { //anonymous class translated into local class class TrackerRunnable implements Runnable { //@Override public void run(){ //super need to be in a non-static context System.out.println(this.toString()); //this refers to the TrackerRunnable instance System.out.println(super.toString()); //super defaults to the same instance!!! Tracker.super.track(event); //Tracker.super refers to BaseTracker Runnable.super.run2(); //Runnable.super refers to Runnable //super.track(event); //ERROR: cannot resolve, super refers to this //BaseTracker.track(event); //ERROR: can only reference static method, .track() is instance method } } Executor.execute(new TrackerRunnable()); } public static void main(String... args) { new Tracker().track2(&quot;&quot;); }}Reference: Java in a Nutshell: How Inner Classes WorkTODO: final keyword:1. class - cannot be subclassed2. method - cannot be overridden3. variable - cannot be assigned more than onceJava memory model: stack, heap,synthetic copydp/dip 是个长度单位。" />
<link rel="canonical" href="http://localhost:8888/2016/08/14/usage-of-java-keyword-final-in-android_98.html" />
<meta property="og:url" content="http://localhost:8888/2016/08/14/usage-of-java-keyword-final-in-android_98.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-08-14T23:32:00-07:00" />
<script type="application/ld+json">
{"url":"http://localhost:8888/2016/08/14/usage-of-java-keyword-final-in-android_98.html","headline":"Java Nested Class - (Original Post: Usage of java keyword “final” in Android)","dateModified":"2016-08-14T23:32:00-07:00","datePublished":"2016-08-14T23:32:00-07:00","author":{"@type":"Person","name":"Weishi Zeng"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8888/2016/08/14/usage-of-java-keyword-final-in-android_98.html"},"description":"Java Nested Classclass OuterClass { ... static class StaticNestedClass { ... } class InnerClass { ... }}1. Static Nested ClassIntuition:Just like a top level class, nested for packaging convenience.Constructor:OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can only direct access outer class static members. (Like any other class accessing OuterClass.java)&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can define both static/non-static members. (members: fields + methods.)Usage://like top-level class, more power to define, less power to accessstatic class StaticNestedClass { private Integer instanceField = 1; private static String staticField = outer_static_field; public static void staticMethod() { String a = outer_static_field; } public void instanceMethod() { String a = outer_static_field; //String b = outer_instance_field; //ERROR: cannot reference non-static field }}2. Inner ClassIntuition:Like a instance member, &quot;belongs to&quot; an outer class instance.Constructor:OuterClass.InnerClass innerObject = outerObject.new InnerClass();Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class.&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. Since it is associated with an instance.Usage://Like a instance member, &quot;belongs to&quot; an outer class instance.class InnerClass { private String inner_instance_field = &quot;inner_instance_field&quot;; public InnerClass () {} public void get_outer_member () { //can access any outer member String a = outer_static_field; String b = outer_private_static_method(); String c = outer_instance_field; inner_instance_field = &quot;&quot;; } //COMPILE ERROR: no static member allowed //public interface inner_interface {}; //an interface is an effective static member //public static String get_static_instance_field () {} //private static String static_field = &quot;static_field&quot;;}2.1. Local ClassIntuition:Defined inside a block (a method, a if block, a for loop). The scope of the class is its enclosing block. A special case of inner class. Thus no static member, a rule inherited from inner class.Constructor: Consequences:&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;But for local classes in static contexts, can only refer to static members of the enclosing class. &quot;Non-static member cannot be referenced from a static context&quot; this rule always applies.&nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. EVEN IF it&#39;s inside a static block.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. A local class can have static members provided that they are constant variables.(A constant variable is a variable of primitive type or type String that is declaredfinal and initialized with a compile-time constant expression.A compile-time constant expression is typically a string or an arithmetic expressionthat can be evaluated at compile time.Note: If a primitive type or a string is defined as a constant and the value is known atcompile time, the compiler replaces the constant name everywhere in the code with its value.This is called a compile-time constant. If the value of the constant in the outside world changes(for example, if it is legislated that pi actually should be 3.975),you will need to recompile any classes that use this constant to get the current value.&nbsp; &nbsp; Local Variable Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final. A local class can use the local variables, method parameters, and even exception parameters that are in its scope, but only if those variables or parameters are declared final. This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined. For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler). The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final.Usage: { class LocalClass { //can access outer member String a = outer_instance_field; String b = outer_static_field; //static String c = &quot;&quot;; //ERROR: no static allowed //final static String d ; //ERROR: not a compile-time constant final static String d = &quot;&quot;; //a constant known at compile time } //static class StaticLocalClass {} //ERROR: local class cannot be static, regardless where.}static { //this is a static context //static class StaticLocalClass {} //ERROR: local class cannot be static, even if in static context class LocalClass { //can access outer member //String a = outer_instance_field; //ERROR: non-static cannot be referenced from static context String b = outer_static_field; //static String c = &quot;&quot;; //ERROR: no static allowed //final static String d ; //ERROR: not a compile-time constant final static String d = &quot;&quot;; //a constant known at compile time }}public void outer_instance_method(Object method_param) { String outer_instance_method_local_var = &quot;&quot;; class LocalClass { //local class at non-static context String f = &quot;&quot;; //can have non-static member /* A local class can have static members provided that they are constant variables. (A constant variable is a variable of primitive type or type String that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. Note: If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value. */ //final static Object d = new NestedClassTest(); //ERROR: this is not a compile time constant final static int e = 5; //need to be string or int. need to know it at compile time String a = outer_instance_field; String b = outer_static_field; String c = outer_instance_method_local_var; //outer_instance_method_local_var need to be final Object abc = method_param; //can access final method param private void local_method() { Object d = method_param; //can access final method param //outer_instance_method_local_var = &quot;&quot;; //ERROR: need to be final //method_param = &quot;&quot;; //ERROR: need to be final outer_instance_field = &quot;&quot;; //no problem interact with outer class field outer_static_field = &quot;&quot;; //can access static or non-static LocalClass a = new LocalClass(); } } //a local class is valid only within the scope defined by its enclosing block. //But the local class has access to outer class members. LocalClass a = new LocalClass(); /* A local class can use the local variables, method parameters, and even exception parameters that are in its scope, but only if those variables or parameters are declared final. This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined. For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler). The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final. */ outer_static_field2 = a; //here, a local class instance outlives local method scope a.local_method();}2.2. Anonymous ClassIntuition:&nbsp;&nbsp;Local class without a name.Constructor://implementing interfacenew InterfacName () { /*class-body*/ }//extending classnew ClassName ( [ argument-list ] ) { /*class-body*/ }Consequences: &nbsp; &nbsp;&nbsp; &nbsp; Enclosing Class Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like local class. &nbsp; &nbsp; Members:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. &nbsp; &nbsp; Local Variable Access:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final. Usage: class Executor {public static void execute(Runnable r){r.run();r.run2();}}class BaseTracker {public void track(Object obj){}}interface Runnable { void run(); //abstract method default void run2(){}; //extension method}class Tracker extends BaseTracker{ private String outer_class_var = &quot;&quot;; //anonymous class public void track1(final Object event) { Executor.execute(new Runnable() { //static String a = &quot;&quot;; //ERROR: no static allowed final static String b = &quot;&quot;; //constant OK String c = outer_class_var; //compiler create a package-level getter for enclosing class&#39;s private variables @Override public void run() { Tracker.super.track(event); //Tracker.super refers to enclosing class&#39;s super class //super.track(event); //ERROR: cannot resolve //BaseTracker.track(event); //ERROR: can only reference static method } }); } //local class public void track2(final Object event) { //anonymous class translated into local class class TrackerRunnable implements Runnable { //@Override public void run(){ //super need to be in a non-static context System.out.println(this.toString()); //this refers to the TrackerRunnable instance System.out.println(super.toString()); //super defaults to the same instance!!! Tracker.super.track(event); //Tracker.super refers to BaseTracker Runnable.super.run2(); //Runnable.super refers to Runnable //super.track(event); //ERROR: cannot resolve, super refers to this //BaseTracker.track(event); //ERROR: can only reference static method, .track() is instance method } } Executor.execute(new TrackerRunnable()); } public static void main(String... args) { new Tracker().track2(&quot;&quot;); }}Reference: Java in a Nutshell: How Inner Classes WorkTODO: final keyword:1. class - cannot be subclassed2. method - cannot be overridden3. variable - cannot be assigned more than onceJava memory model: stack, heap,synthetic copydp/dip 是个长度单位。","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:8888/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Java Nested Class - (Original Post: Usage of java keyword &quot;final&quot; in Android)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-08-14T23:32:00-07:00" itemprop="datePublished">Aug 14, 2016
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Weishi Zeng</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div dir="ltr" style="text-align: left;" trbidi="on"><h2 style="text-align: left;">Java Nested Class</h2><pre class="prettyprint">class OuterClass {<br />    ...<br />    static class StaticNestedClass {<br />        ...<br />    }<br />    class InnerClass {<br />        ...<br />    }<br />}</pre><h3 style="text-align: left;">1. Static Nested Class</h3><h4 style="text-align: left;"><b>Intuition</b>:</h4>Just like a top level class, nested for packaging convenience.<br /><h4 style="text-align: left;">Constructor:</h4><pre class="prettyprint" style="text-align: left;">OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();<br /></pre><h4 style="text-align: left;">Consequences:</h4>&nbsp; &nbsp; Enclosing Class Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can only direct access outer class static members. (Like any other class accessing OuterClass.java)<br />&nbsp; &nbsp; Members:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can define both static/non-static members. (members: fields + methods.)<br /><h4 style="text-align: left;">Usage:</h4><pre class="prettyprint">//like top-level class, more power to define, less power to access<br />static class StaticNestedClass {<br />    private Integer instanceField = 1;<br />    private static String staticField = outer_static_field;<br />    public static void staticMethod() {<br />        String a = outer_static_field;<br />    }<br />    public void instanceMethod() {<br />        String a = outer_static_field;<br />        //String b = outer_instance_field;  //ERROR: cannot reference non-static field<br />    }<br />}</pre><h3 style="text-align: left;">2. Inner Class</h3><h4 style="text-align: left;"><b>Intuition</b>:</h4>Like a instance member, "belongs to" an outer class instance.<br /><h4 style="text-align: left;">Constructor:</h4><pre class="prettyprint" style="text-align: left;">OuterClass.InnerClass innerObject = outerObject.new InnerClass();<br /></pre>Consequences:<br />&nbsp; &nbsp; Enclosing Class Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class.<br />&nbsp; &nbsp; Members:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. Since it is associated with an instance.<br /><h4 style="text-align: left;">Usage:</h4><pre class="prettyprint">//Like a instance member, "belongs to" an outer class instance.<br />class InnerClass {<br /><br />    private String inner_instance_field = "inner_instance_field";<br /><br />    public InnerClass () {}<br /><br />    public void get_outer_member () { //can access any outer member<br />        String a = outer_static_field;<br />        String b = outer_private_static_method();<br />        String c = outer_instance_field;<br />        inner_instance_field = "";<br />    }<br /><br />    //COMPILE ERROR: no static member allowed<br />    //public interface inner_interface {};  //an interface is an effective static member<br />    //public static String get_static_instance_field () {}<br />    //private static String static_field = "static_field";<br />}</pre><h3 style="text-align: left;">2.1. Local Class</h3><h4 style="text-align: left;"><b>Intuition</b>:</h4>Defined inside a block (a method, a if block, a for loop). The scope of the class is its enclosing block. <br />A special case of inner class. Thus no static member, a rule inherited from inner class.<br /><h4 style="text-align: left;">Constructor:</h4><h4 style="text-align: left;"> Consequences:</h4>&nbsp; &nbsp; Enclosing Class Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like any method in outer class. <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;But for local classes in static contexts, can only refer to static members of the enclosing class.  "Non-static member cannot be referenced from a static context" this rule always applies.<br />&nbsp; &nbsp; Members:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. EVEN IF it's inside a static block.<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. <br /><pre class="info">A local class can have static members provided that they are constant variables.<br />(A constant variable is a variable of primitive type or type String that is declared<br />final and initialized with a compile-time constant expression.<br />A compile-time constant expression is typically a string or an arithmetic expression<br />that can be evaluated at compile time.<br />Note: If a primitive type or a string is defined as a constant and the value is known at<br />compile time, the compiler replaces the constant name everywhere in the code with its value.<br />This is called a compile-time constant. If the value of the constant in the outside world changes<br />(for example, if it is legislated that pi actually should be 3.975),<br />you will need to recompile any classes that use this constant to get the current value.<br /></pre><br />&nbsp; &nbsp; Local Variable Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final.  <br /><pre class="info">A local class can use the local variables, method parameters, <br />and even exception parameters that are in its scope, <br />but only if those variables or parameters are declared final. <br />This is because the lifetime of an instance of a local class can be <br />much longer than the execution of the method in which the class is defined. <br />For this reason, a local class must have a private internal copy of <br />all local variables it uses (these copies are automatically generated by the compiler). <br />The only way to ensure that the local variable and the private copy <br />are always the same is to insist that the local variable is final.<br /></pre>Usage:<br /><pre class="prettyprint" style="text-align: left;">  <br />{<br />    class LocalClass {<br />        //can access outer member<br />        String a = outer_instance_field;<br />        String b = outer_static_field;<br /><br />        //static String c = "";  //ERROR: no static allowed<br />        //final static String d ; //ERROR: not a compile-time constant<br />        final static String d = ""; //a constant known at compile time<br />    }<br />    //static class StaticLocalClass {} //ERROR: local class cannot be static, regardless where.<br />}<br /><br />static {  //this is a static context<br />    //static class StaticLocalClass {} //ERROR: local class cannot be static, even if in static context<br />    class LocalClass {<br />        //can access outer member<br />        //String a = outer_instance_field; //ERROR: non-static cannot be referenced from static context<br />        String b = outer_static_field;<br /><br />        //static String c = "";  //ERROR: no static allowed<br />        //final static String d ; //ERROR: not a compile-time constant<br />        final static String d = ""; //a constant known at compile time<br />    }<br />}<br /><br />public void outer_instance_method(Object method_param) {<br />    String outer_instance_method_local_var = "";<br />    class LocalClass { //local class at non-static context<br />        String f = "";   //can have non-static member<br /><br />        /*<br />        A local class can have static members provided that they are constant variables.<br />        (A constant variable is a variable of primitive type or type String that is declared<br />        final and initialized with a compile-time constant expression.<br />        A compile-time constant expression is typically a string or an arithmetic expression<br />        that can be evaluated at compile time.<br />        Note: If a primitive type or a string is defined as a constant and the value is known at<br />        compile time, the compiler replaces the constant name everywhere in the code with its value.<br />        This is called a compile-time constant. If the value of the constant in the outside world changes<br />        (for example, if it is legislated that pi actually should be 3.975),<br />        you will need to recompile any classes that use this constant to get the current value.<br />         */<br />        //final static Object d = new NestedClassTest(); //ERROR: this is not a compile time constant<br /><br />        final static int e = 5;  //need to be string or int. need to know it at compile time<br /><br />        String a = outer_instance_field;<br />        String b = outer_static_field;<br />        String c = outer_instance_method_local_var; //outer_instance_method_local_var need to be final<br /><br />        Object abc = method_param; //can access final method param<br /><br />        private void local_method() {<br />            Object d = method_param; //can access final method param<br /><br />            //outer_instance_method_local_var = "";  //ERROR: need to be final<br />            //method_param = ""; //ERROR: need to be final<br /><br />            outer_instance_field = ""; //no problem interact with outer class field<br />            outer_static_field = "";   //can access static or non-static<br /><br />            LocalClass a = new LocalClass();<br />        }<br />    }<br /><br />    //a local class is valid only within the scope defined by its enclosing block.<br />    //But the local class has access to outer class members.<br />    LocalClass a = new LocalClass();<br />    /*<br />    A local class can use the local variables, method parameters,<br />    and even exception parameters that are in its scope,<br />    but only if those variables or parameters are declared final.<br />    This is because the lifetime of an instance of a local class can be<br />    much longer than the execution of the method in which the class is defined.<br />    For this reason, a local class must have a private internal copy of<br />    all local variables it uses (these copies are automatically generated by the compiler).<br />    The only way to ensure that the local variable and the private copy<br />    are always the same is to insist that the local variable is final.<br />     */<br />    outer_static_field2 = a; //here, a local class instance outlives local method scope<br />    a.local_method();<br />}<br /></pre><h3 style="text-align: left;">2.2. Anonymous Class</h3><h4 style="text-align: left;"><b>Intuition</b>:&nbsp;</h4>&nbsp;Local class without a name.<br /><h4 style="text-align: left;">Constructor:</h4><pre class="prettyprint">//implementing interface<br />new InterfacName () { /*class-body*/ }<br /><br />//extending class<br />new ClassName ( [ argument-list ] ) { /*class-body*/ }<br /></pre>Consequences: &nbsp; &nbsp;<br />&nbsp; &nbsp; Enclosing Class Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Direct access to all outer class members. Just like local class. <br />&nbsp; &nbsp; Members:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can NOT define any static members. <br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Only exception is for static final String/primitive. As they are stored like a constant. <br />&nbsp; &nbsp; Local Variable Access:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Can access local variables or method parameters that is final. <br />Usage:  <br /><pre class="prettyprint">class Executor {public static void execute(Runnable r){r.run();r.run2();}}<br />class BaseTracker {public void track(Object obj){}}<br />interface Runnable {<br />    void  run();  //abstract method<br />    default void run2(){};  //extension method<br />}<br /><br />class Tracker extends BaseTracker{<br />    private String outer_class_var = "";<br /><br />    //anonymous class<br />    public void track1(final Object event) {<br />        Executor.execute(new Runnable() {<br />            //static String a = ""; //ERROR: no static allowed<br />            final static String b = ""; //constant OK<br />            String c = outer_class_var;   //compiler create a package-level getter for enclosing class's private variables<br /><br />            @Override<br />            public void run() {<br />                Tracker.super.track(event);  //Tracker.super refers to enclosing class's super class<br />                //super.track(event); //ERROR: cannot resolve<br />                //BaseTracker.track(event);  //ERROR: can only reference static method<br />            }<br />        });<br />    }<br /><br />    //local class<br />    public void track2(final Object event) {<br />        //anonymous class translated into local class<br />        class TrackerRunnable implements Runnable {<br />            //@Override<br />            public void run(){<br />                //super need to be in a non-static context<br /><br />                System.out.println(this.toString()); //this refers to the TrackerRunnable instance<br />                System.out.println(super.toString()); //super defaults to the same instance!!!<br /><br />                Tracker.super.track(event);  //Tracker.super refers to BaseTracker<br />                Runnable.super.run2(); //Runnable.super refers to Runnable<br /><br />                //super.track(event); //ERROR: cannot resolve, super refers to this<br />                //BaseTracker.track(event);  //ERROR: can only reference static method, .track() is instance method<br />            }<br />        }<br />        Executor.execute(new TrackerRunnable());<br />    }<br /><br />    public static void main(String... args) {<br />        new Tracker().track2("");<br />    }<br />}<br /></pre>Reference: <a href="http://docstore.mik.ua/orelly/java-ent/jnut/ch03_13.htm">Java in a Nutshell: How Inner Classes Work</a><br /><br />TODO:  final keyword:<br />1. class - cannot be subclassed<br />2. method - cannot be overridden<br />3. variable - cannot be assigned more than once<br />Java memory model: stack, heap,<br />synthetic copy<br />dp/dip 是个长度单位。  </div>
  </div><a class="u-url" href="/2016/08/14/usage-of-java-keyword-final-in-android_98.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
