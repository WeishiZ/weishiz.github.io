<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.0">Jekyll</generator><link href="http://localhost:8888/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:8888/" rel="alternate" type="text/html" /><updated>2018-04-21T18:58:43-07:00</updated><id>http://localhost:8888/</id><title type="html">What A Day Today</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:8888/jekyll/update/2018/04/21/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-04-21T17:13:02-07:00</published><updated>2018-04-21T17:13:02-07:00</updated><id>http://localhost:8888/jekyll/update/2018/04/21/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:8888/jekyll/update/2018/04/21/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Reference Counting in iOS vs. Garbage Collection in Android</title><link href="http://localhost:8888/2017/01/05/reference-counting-in-ios-vs-garbage.html" rel="alternate" type="text/html" title="Reference Counting in iOS vs. Garbage Collection in Android" /><published>2017-01-05T14:28:00-08:00</published><updated>2017-01-05T14:28:00-08:00</updated><id>http://localhost:8888/2017/01/05/reference-counting-in-ios-vs-garbage</id><content type="html" xml:base="http://localhost:8888/2017/01/05/reference-counting-in-ios-vs-garbage.html">&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;Automatic Reference Counting (ARC) vs. Tracing Garbage Collection (GC)&lt;br /&gt;&lt;br /&gt;http://softwareengineering.stackexchange.com/questions/285333/how-does-garbage-collection-compare-to-reference-counting&lt;br /&gt;&lt;br /&gt;http://www.cubrid.org/blog/dev-platform/understanding-java-garbage-collection/&lt;br /&gt;&lt;br /&gt;&lt;div style=&quot;background-color: white; border: 0px; clear: both; color: #242729; font-family: Arial, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, sans-serif; font-size: 15px; margin-bottom: 1em; padding: 0px;&quot;&gt;Automatic Reference counting or ARC, is a form of garbage collection in which objects are deallocated once there are no more references to them, i.e. no other variable refers to the object in particular. Each object, under ARC, contains a reference counter, stored as an extra field in memory, which is incremented every time you set a variable to that object (i.e. a new reference to the object is created), and is decremented every time you set a reference to the object to nil/null, or a reference goes out of scope (i.e. it is deleted when the stack unwinds), once the reference counter goes down to zero, the object takes care of deleting itself, calling the destructor and freeing the allocated memory. This approach has a significant weakness, as we shall see below.&lt;/div&gt;&lt;div style=&quot;background-color: white; border: 0px; clear: both; color: #242729; font-family: Arial, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, sans-serif; font-size: 15px; margin-bottom: 1em; padding: 0px;&quot;&gt;&quot;There's no need to worry about memory management because it's all taken care of for you by reference counting,&quot; that's actually a misconception you still do need to take care to avoid certain conditions, namely circular references, in order for ARC to function correctly. A circular reference is when an object A holds a strong reference to an object B, which itself holds a strong reference to the same object A, in this situation neither object is going to be deallocated because in order for A to be deallocated its reference counter must be decremented to zero, but at least one of those references is object B, for object B to be deallocated, its reference counter must also be decremented to 0, but at least one of those references is object A, can you see the problem? ARC solves this by allowing the programmer to give compiler hints about how different object references should be treated, there are two types of references: strong references and weak references. Strong references are, as I mentioned above, a type of reference which prolongs the life of the referenced object (increments its reference counter), weak references are a type of reference which does not prolong the life of an object (that is, it does not increment the object's reference counter), but that would mean the referenced object could get deallocated and you'd would be left with an invalid reference pointing to junk memory. In order for this situation to be avoided, the weak reference is set to a safe value (e.g. nil in Objective-C) once the object is deallocated, thus the object has an extra responsibility of keeping track of all weak references and setting them to a safe value once it deletes itself. Weak references are usually used in a child-parent object relation, the parent holds a strong reference to all it's child objects, whereas the child objects hold a weak reference to the parent, the rationale being that in most cases if you no longer care about the parent object, you most likely no longer care about the child objects either.&lt;/div&gt;&lt;div style=&quot;background-color: white; border: 0px; clear: both; color: #242729; font-family: Arial, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, sans-serif; font-size: 15px; margin-bottom: 1em; padding: 0px;&quot;&gt;Tracing garbage collection (i.e. what is most often referred to as simply garbage collection) involves keeping a list of all root objects (i.e. those stored in global variables, the local variables of the main procedure, etc) and tracing which objects are reachable (marking each object encountered) from those root objects. Once the garbage collector has gone through all the objects referenced by the root objects, the GC now goes through every allocated object, if it is marked as reachable it stays in memory, if it is not marked as reachable it is deallocated, this is known as the mark-and-sweep algorithm. This has the advantage of not suffering from the circular reference problem as: if neither the mutually referenced object A and object B are referenced by any other object reachable from the root objects, neither object A nor object B are marked as reachable and are both deallocated. Tracing garbage collectors run in certain intervals pausing all threads, which can lead to inconsistent performance (sporadic pauses). The algorithm described here is a very basic description, modern GC's are usually much more advanced using an object generation system, tri-color sets etc, and also perform other tasks such as defragmentation of the program's memory space by moving the objects to a contiguous storage space, this is the reason why GC'ed languages such as C# and Java do not allow pointers. One significant weakness of tracing garbage collectors is that class destructors are no longer deterministic, that is the programmer cannot tell when an object is going to be garbage collected in-fact GC'ed languages do not even allow the programmer to specify a class destructor, thus classes can no longer be used to encapsulate the management of resources such as file handles, database connections, etc. The responsibility is left on the programmer to close open files, database connections manually, hence why languages such as Java have a finally keyword (in the try,catch block) to make sure the cleanup code is always executed before the stack unwinds, whereas in C++ (no GC) such resources are handled by a wrapper object (allocated on the stack) which acquires the resource in the constructor and releases it in the destructor, which is always called as the object is removed from the stack.&lt;/div&gt;&lt;div style=&quot;background-color: white; border: 0px; clear: both; color: #242729; font-family: Arial, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, sans-serif; font-size: 15px; margin-bottom: 1em; padding: 0px;&quot;&gt;As for performance, both have performance penalties. Automatic reference counting delivers a more consistent performance, no pauses, but slows down your application as a whole as every assignment of an object to a variable, every deallocation of an object, etc, will need an associated incrementation/decrementation of the reference counter, and taking care of reassigning the weak references and calling each destructor of each object being deallocated. GC does not have the performance penalty of ARC when dealing with object references; however, it incurs pauses while it is collecting garbage (rendering unusable for real-time processing systems) and requires a large memory space in order for it to function effectively such that it is not forced to run, thus pausing execution, too often.&lt;/div&gt;&lt;div style=&quot;background-color: white; border: 0px; clear: both; color: #242729; font-family: Arial, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, sans-serif; font-size: 15px; margin-bottom: 1em; padding: 0px;&quot;&gt;As you can see both have their own advantages and disadvantages, there is no clear cut ARC is better or GC is better, both are compromises.&lt;/div&gt;&lt;div style=&quot;background-color: white; border: 0px; clear: both; color: #242729; font-family: Arial, &amp;quot;Helvetica Neue&amp;quot;, Helvetica, sans-serif; font-size: 15px; margin-bottom: 1em; padding: 0px;&quot;&gt;&lt;strong style=&quot;border: 0px; margin: 0px; padding: 0px;&quot;&gt;PS:&lt;/strong&gt;&amp;nbsp;ARC also becomes problematic when objects are shared across multiple threads requiring atomic incrementation/decrementation of the reference counter, which itself presents a whole new array of complexities and problems. This should answer your question as to &quot;why would anyone use garbage collection&quot;.&lt;/div&gt;&lt;/div&gt;</content><author><name>Weishi Zeng</name></author><summary type="html">Automatic Reference Counting (ARC) vs. Tracing Garbage Collection (GC)http://softwareengineering.stackexchange.com/questions/285333/how-does-garbage-collection-compare-to-reference-countinghttp://www.cubrid.org/blog/dev-platform/understanding-java-garbage-collection/Automatic Reference counting or ARC, is a form of garbage collection in which objects are deallocated once there are no more references to them, i.e. no other variable refers to the object in particular. Each object, under ARC, contains a reference counter, stored as an extra field in memory, which is incremented every time you set a variable to that object (i.e. a new reference to the object is created), and is decremented every time you set a reference to the object to nil/null, or a reference goes out of scope (i.e. it is deleted when the stack unwinds), once the reference counter goes down to zero, the object takes care of deleting itself, calling the destructor and freeing the allocated memory. This approach has a significant weakness, as we shall see below.&quot;There's no need to worry about memory management because it's all taken care of for you by reference counting,&quot; that's actually a misconception you still do need to take care to avoid certain conditions, namely circular references, in order for ARC to function correctly. A circular reference is when an object A holds a strong reference to an object B, which itself holds a strong reference to the same object A, in this situation neither object is going to be deallocated because in order for A to be deallocated its reference counter must be decremented to zero, but at least one of those references is object B, for object B to be deallocated, its reference counter must also be decremented to 0, but at least one of those references is object A, can you see the problem? ARC solves this by allowing the programmer to give compiler hints about how different object references should be treated, there are two types of references: strong references and weak references. Strong references are, as I mentioned above, a type of reference which prolongs the life of the referenced object (increments its reference counter), weak references are a type of reference which does not prolong the life of an object (that is, it does not increment the object's reference counter), but that would mean the referenced object could get deallocated and you'd would be left with an invalid reference pointing to junk memory. In order for this situation to be avoided, the weak reference is set to a safe value (e.g. nil in Objective-C) once the object is deallocated, thus the object has an extra responsibility of keeping track of all weak references and setting them to a safe value once it deletes itself. Weak references are usually used in a child-parent object relation, the parent holds a strong reference to all it's child objects, whereas the child objects hold a weak reference to the parent, the rationale being that in most cases if you no longer care about the parent object, you most likely no longer care about the child objects either.Tracing garbage collection (i.e. what is most often referred to as simply garbage collection) involves keeping a list of all root objects (i.e. those stored in global variables, the local variables of the main procedure, etc) and tracing which objects are reachable (marking each object encountered) from those root objects. Once the garbage collector has gone through all the objects referenced by the root objects, the GC now goes through every allocated object, if it is marked as reachable it stays in memory, if it is not marked as reachable it is deallocated, this is known as the mark-and-sweep algorithm. This has the advantage of not suffering from the circular reference problem as: if neither the mutually referenced object A and object B are referenced by any other object reachable from the root objects, neither object A nor object B are marked as reachable and are both deallocated. Tracing garbage collectors run in certain intervals pausing all threads, which can lead to inconsistent performance (sporadic pauses). The algorithm described here is a very basic description, modern GC's are usually much more advanced using an object generation system, tri-color sets etc, and also perform other tasks such as defragmentation of the program's memory space by moving the objects to a contiguous storage space, this is the reason why GC'ed languages such as C# and Java do not allow pointers. One significant weakness of tracing garbage collectors is that class destructors are no longer deterministic, that is the programmer cannot tell when an object is going to be garbage collected in-fact GC'ed languages do not even allow the programmer to specify a class destructor, thus classes can no longer be used to encapsulate the management of resources such as file handles, database connections, etc. The responsibility is left on the programmer to close open files, database connections manually, hence why languages such as Java have a finally keyword (in the try,catch block) to make sure the cleanup code is always executed before the stack unwinds, whereas in C++ (no GC) such resources are handled by a wrapper object (allocated on the stack) which acquires the resource in the constructor and releases it in the destructor, which is always called as the object is removed from the stack.As for performance, both have performance penalties. Automatic reference counting delivers a more consistent performance, no pauses, but slows down your application as a whole as every assignment of an object to a variable, every deallocation of an object, etc, will need an associated incrementation/decrementation of the reference counter, and taking care of reassigning the weak references and calling each destructor of each object being deallocated. GC does not have the performance penalty of ARC when dealing with object references; however, it incurs pauses while it is collecting garbage (rendering unusable for real-time processing systems) and requires a large memory space in order for it to function effectively such that it is not forced to run, thus pausing execution, too often.As you can see both have their own advantages and disadvantages, there is no clear cut ARC is better or GC is better, both are compromises.PS:&amp;nbsp;ARC also becomes problematic when objects are shared across multiple threads requiring atomic incrementation/decrementation of the reference counter, which itself presents a whole new array of complexities and problems. This should answer your question as to &quot;why would anyone use garbage collection&quot;.</summary></entry><entry><title type="html">TODO List</title><link href="http://localhost:8888/2016/08/31/todo-list.html" rel="alternate" type="text/html" title="TODO List" /><published>2016-08-31T23:37:00-07:00</published><updated>2016-08-31T23:37:00-07:00</updated><id>http://localhost:8888/2016/08/31/todo-list</id><content type="html" xml:base="http://localhost:8888/2016/08/31/todo-list.html">&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;TODO&lt;br /&gt;&lt;br /&gt;1. Reference counting in iOS vs Garbage Collection in Android&lt;br /&gt;2.&lt;br /&gt;&lt;div class=&quot;p1&quot;&gt;syncronized key word, (monitor lock)&lt;/div&gt;&lt;div class=&quot;p2&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;p2&quot;&gt;singleton&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;p1&quot;&gt;volatile keyword&lt;/div&gt;&lt;div class=&quot;p2&quot;&gt;&lt;br /&gt;&lt;/div&gt;&lt;div class=&quot;p1&quot;&gt;singleton with param&lt;/div&gt;&lt;ul class=&quot;ul1&quot;&gt;&lt;li class=&quot;li1&quot;&gt;getInstance(Context context)&lt;/li&gt;&lt;li class=&quot;li1&quot;&gt;getInstance(null)&lt;/li&gt;&lt;/ul&gt;&lt;br /&gt;&lt;div class=&quot;p1&quot;&gt;ENUM&lt;br /&gt;&lt;br /&gt;unloading of class: why in android code, you shouldn't rely on static class variables.&lt;br /&gt;https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.7&lt;br /&gt;&lt;br /&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Weishi Zeng</name></author><summary type="html">TODO1. Reference counting in iOS vs Garbage Collection in Android2.syncronized key word, (monitor lock)singleton&amp;nbsp;volatile keywordsingleton with paramgetInstance(Context context)getInstance(null)ENUMunloading of class: why in android code, you shouldn't rely on static class variables.https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.7</summary></entry><entry><title type="html">Java Nested Class - (Original Post: Usage of java keyword “final” in Android)</title><link href="http://localhost:8888/2016/08/14/usage-of-java-keyword-final-in-android_98.html" rel="alternate" type="text/html" title="Java Nested Class - (Original Post: Usage of java keyword &quot;final&quot; in Android)" /><published>2016-08-14T23:32:00-07:00</published><updated>2016-08-14T23:32:00-07:00</updated><id>http://localhost:8888/2016/08/14/usage-of-java-keyword-final-in-android_98</id><content type="html" xml:base="http://localhost:8888/2016/08/14/usage-of-java-keyword-final-in-android_98.html">&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;&lt;h2 style=&quot;text-align: left;&quot;&gt;Java Nested Class&lt;/h2&gt;&lt;pre class=&quot;prettyprint&quot;&gt;class OuterClass {&lt;br /&gt;    ...&lt;br /&gt;    static class StaticNestedClass {&lt;br /&gt;        ...&lt;br /&gt;    }&lt;br /&gt;    class InnerClass {&lt;br /&gt;        ...&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&lt;h3 style=&quot;text-align: left;&quot;&gt;1. Static Nested Class&lt;/h3&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;&lt;b&gt;Intuition&lt;/b&gt;:&lt;/h4&gt;Just like a top level class, nested for packaging convenience.&lt;br /&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;Constructor:&lt;/h4&gt;&lt;pre class=&quot;prettyprint&quot; style=&quot;text-align: left;&quot;&gt;OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();&lt;br /&gt;&lt;/pre&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;Consequences:&lt;/h4&gt;&amp;nbsp; &amp;nbsp; Enclosing Class Access:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can only direct access outer class static members. (Like any other class accessing OuterClass.java)&lt;br /&gt;&amp;nbsp; &amp;nbsp; Members:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can define both static/non-static members. (members: fields + methods.)&lt;br /&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;Usage:&lt;/h4&gt;&lt;pre class=&quot;prettyprint&quot;&gt;//like top-level class, more power to define, less power to access&lt;br /&gt;static class StaticNestedClass {&lt;br /&gt;    private Integer instanceField = 1;&lt;br /&gt;    private static String staticField = outer_static_field;&lt;br /&gt;    public static void staticMethod() {&lt;br /&gt;        String a = outer_static_field;&lt;br /&gt;    }&lt;br /&gt;    public void instanceMethod() {&lt;br /&gt;        String a = outer_static_field;&lt;br /&gt;        //String b = outer_instance_field;  //ERROR: cannot reference non-static field&lt;br /&gt;    }&lt;br /&gt;}&lt;/pre&gt;&lt;h3 style=&quot;text-align: left;&quot;&gt;2. Inner Class&lt;/h3&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;&lt;b&gt;Intuition&lt;/b&gt;:&lt;/h4&gt;Like a instance member, &quot;belongs to&quot; an outer class instance.&lt;br /&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;Constructor:&lt;/h4&gt;&lt;pre class=&quot;prettyprint&quot; style=&quot;text-align: left;&quot;&gt;OuterClass.InnerClass innerObject = outerObject.new InnerClass();&lt;br /&gt;&lt;/pre&gt;Consequences:&lt;br /&gt;&amp;nbsp; &amp;nbsp; Enclosing Class Access:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Direct access to all outer class members. Just like any method in outer class.&lt;br /&gt;&amp;nbsp; &amp;nbsp; Members:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can NOT define any static members. Since it is associated with an instance.&lt;br /&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;Usage:&lt;/h4&gt;&lt;pre class=&quot;prettyprint&quot;&gt;//Like a instance member, &quot;belongs to&quot; an outer class instance.&lt;br /&gt;class InnerClass {&lt;br /&gt;&lt;br /&gt;    private String inner_instance_field = &quot;inner_instance_field&quot;;&lt;br /&gt;&lt;br /&gt;    public InnerClass () {}&lt;br /&gt;&lt;br /&gt;    public void get_outer_member () { //can access any outer member&lt;br /&gt;        String a = outer_static_field;&lt;br /&gt;        String b = outer_private_static_method();&lt;br /&gt;        String c = outer_instance_field;&lt;br /&gt;        inner_instance_field = &quot;&quot;;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    //COMPILE ERROR: no static member allowed&lt;br /&gt;    //public interface inner_interface {};  //an interface is an effective static member&lt;br /&gt;    //public static String get_static_instance_field () {}&lt;br /&gt;    //private static String static_field = &quot;static_field&quot;;&lt;br /&gt;}&lt;/pre&gt;&lt;h3 style=&quot;text-align: left;&quot;&gt;2.1. Local Class&lt;/h3&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;&lt;b&gt;Intuition&lt;/b&gt;:&lt;/h4&gt;Defined inside a block (a method, a if block, a for loop). The scope of the class is its enclosing block. &lt;br /&gt;A special case of inner class. Thus no static member, a rule inherited from inner class.&lt;br /&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;Constructor:&lt;/h4&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt; Consequences:&lt;/h4&gt;&amp;nbsp; &amp;nbsp; Enclosing Class Access:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Direct access to all outer class members. Just like any method in outer class. &lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;But for local classes in static contexts, can only refer to static members of the enclosing class.  &quot;Non-static member cannot be referenced from a static context&quot; this rule always applies.&lt;br /&gt;&amp;nbsp; &amp;nbsp; Members:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can NOT define any static members. EVEN IF it's inside a static block.&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Only exception is for static final String/primitive. As they are stored like a constant. &lt;br /&gt;&lt;pre class=&quot;info&quot;&gt;A local class can have static members provided that they are constant variables.&lt;br /&gt;(A constant variable is a variable of primitive type or type String that is declared&lt;br /&gt;final and initialized with a compile-time constant expression.&lt;br /&gt;A compile-time constant expression is typically a string or an arithmetic expression&lt;br /&gt;that can be evaluated at compile time.&lt;br /&gt;Note: If a primitive type or a string is defined as a constant and the value is known at&lt;br /&gt;compile time, the compiler replaces the constant name everywhere in the code with its value.&lt;br /&gt;This is called a compile-time constant. If the value of the constant in the outside world changes&lt;br /&gt;(for example, if it is legislated that pi actually should be 3.975),&lt;br /&gt;you will need to recompile any classes that use this constant to get the current value.&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&amp;nbsp; &amp;nbsp; Local Variable Access:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can access local variables or method parameters that is final.  &lt;br /&gt;&lt;pre class=&quot;info&quot;&gt;A local class can use the local variables, method parameters, &lt;br /&gt;and even exception parameters that are in its scope, &lt;br /&gt;but only if those variables or parameters are declared final. &lt;br /&gt;This is because the lifetime of an instance of a local class can be &lt;br /&gt;much longer than the execution of the method in which the class is defined. &lt;br /&gt;For this reason, a local class must have a private internal copy of &lt;br /&gt;all local variables it uses (these copies are automatically generated by the compiler). &lt;br /&gt;The only way to ensure that the local variable and the private copy &lt;br /&gt;are always the same is to insist that the local variable is final.&lt;br /&gt;&lt;/pre&gt;Usage:&lt;br /&gt;&lt;pre class=&quot;prettyprint&quot; style=&quot;text-align: left;&quot;&gt;  &lt;br /&gt;{&lt;br /&gt;    class LocalClass {&lt;br /&gt;        //can access outer member&lt;br /&gt;        String a = outer_instance_field;&lt;br /&gt;        String b = outer_static_field;&lt;br /&gt;&lt;br /&gt;        //static String c = &quot;&quot;;  //ERROR: no static allowed&lt;br /&gt;        //final static String d ; //ERROR: not a compile-time constant&lt;br /&gt;        final static String d = &quot;&quot;; //a constant known at compile time&lt;br /&gt;    }&lt;br /&gt;    //static class StaticLocalClass {} //ERROR: local class cannot be static, regardless where.&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;static {  //this is a static context&lt;br /&gt;    //static class StaticLocalClass {} //ERROR: local class cannot be static, even if in static context&lt;br /&gt;    class LocalClass {&lt;br /&gt;        //can access outer member&lt;br /&gt;        //String a = outer_instance_field; //ERROR: non-static cannot be referenced from static context&lt;br /&gt;        String b = outer_static_field;&lt;br /&gt;&lt;br /&gt;        //static String c = &quot;&quot;;  //ERROR: no static allowed&lt;br /&gt;        //final static String d ; //ERROR: not a compile-time constant&lt;br /&gt;        final static String d = &quot;&quot;; //a constant known at compile time&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;public void outer_instance_method(Object method_param) {&lt;br /&gt;    String outer_instance_method_local_var = &quot;&quot;;&lt;br /&gt;    class LocalClass { //local class at non-static context&lt;br /&gt;        String f = &quot;&quot;;   //can have non-static member&lt;br /&gt;&lt;br /&gt;        /*&lt;br /&gt;        A local class can have static members provided that they are constant variables.&lt;br /&gt;        (A constant variable is a variable of primitive type or type String that is declared&lt;br /&gt;        final and initialized with a compile-time constant expression.&lt;br /&gt;        A compile-time constant expression is typically a string or an arithmetic expression&lt;br /&gt;        that can be evaluated at compile time.&lt;br /&gt;        Note: If a primitive type or a string is defined as a constant and the value is known at&lt;br /&gt;        compile time, the compiler replaces the constant name everywhere in the code with its value.&lt;br /&gt;        This is called a compile-time constant. If the value of the constant in the outside world changes&lt;br /&gt;        (for example, if it is legislated that pi actually should be 3.975),&lt;br /&gt;        you will need to recompile any classes that use this constant to get the current value.&lt;br /&gt;         */&lt;br /&gt;        //final static Object d = new NestedClassTest(); //ERROR: this is not a compile time constant&lt;br /&gt;&lt;br /&gt;        final static int e = 5;  //need to be string or int. need to know it at compile time&lt;br /&gt;&lt;br /&gt;        String a = outer_instance_field;&lt;br /&gt;        String b = outer_static_field;&lt;br /&gt;        String c = outer_instance_method_local_var; //outer_instance_method_local_var need to be final&lt;br /&gt;&lt;br /&gt;        Object abc = method_param; //can access final method param&lt;br /&gt;&lt;br /&gt;        private void local_method() {&lt;br /&gt;            Object d = method_param; //can access final method param&lt;br /&gt;&lt;br /&gt;            //outer_instance_method_local_var = &quot;&quot;;  //ERROR: need to be final&lt;br /&gt;            //method_param = &quot;&quot;; //ERROR: need to be final&lt;br /&gt;&lt;br /&gt;            outer_instance_field = &quot;&quot;; //no problem interact with outer class field&lt;br /&gt;            outer_static_field = &quot;&quot;;   //can access static or non-static&lt;br /&gt;&lt;br /&gt;            LocalClass a = new LocalClass();&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    //a local class is valid only within the scope defined by its enclosing block.&lt;br /&gt;    //But the local class has access to outer class members.&lt;br /&gt;    LocalClass a = new LocalClass();&lt;br /&gt;    /*&lt;br /&gt;    A local class can use the local variables, method parameters,&lt;br /&gt;    and even exception parameters that are in its scope,&lt;br /&gt;    but only if those variables or parameters are declared final.&lt;br /&gt;    This is because the lifetime of an instance of a local class can be&lt;br /&gt;    much longer than the execution of the method in which the class is defined.&lt;br /&gt;    For this reason, a local class must have a private internal copy of&lt;br /&gt;    all local variables it uses (these copies are automatically generated by the compiler).&lt;br /&gt;    The only way to ensure that the local variable and the private copy&lt;br /&gt;    are always the same is to insist that the local variable is final.&lt;br /&gt;     */&lt;br /&gt;    outer_static_field2 = a; //here, a local class instance outlives local method scope&lt;br /&gt;    a.local_method();&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;h3 style=&quot;text-align: left;&quot;&gt;2.2. Anonymous Class&lt;/h3&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;&lt;b&gt;Intuition&lt;/b&gt;:&amp;nbsp;&lt;/h4&gt;&amp;nbsp;Local class without a name.&lt;br /&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;Constructor:&lt;/h4&gt;&lt;pre class=&quot;prettyprint&quot;&gt;//implementing interface&lt;br /&gt;new InterfacName () { /*class-body*/ }&lt;br /&gt;&lt;br /&gt;//extending class&lt;br /&gt;new ClassName ( [ argument-list ] ) { /*class-body*/ }&lt;br /&gt;&lt;/pre&gt;Consequences: &amp;nbsp; &amp;nbsp;&lt;br /&gt;&amp;nbsp; &amp;nbsp; Enclosing Class Access:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Direct access to all outer class members. Just like local class. &lt;br /&gt;&amp;nbsp; &amp;nbsp; Members:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can NOT define any static members. &lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Only exception is for static final String/primitive. As they are stored like a constant. &lt;br /&gt;&amp;nbsp; &amp;nbsp; Local Variable Access:&lt;br /&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can access local variables or method parameters that is final. &lt;br /&gt;Usage:  &lt;br /&gt;&lt;pre class=&quot;prettyprint&quot;&gt;class Executor {public static void execute(Runnable r){r.run();r.run2();}}&lt;br /&gt;class BaseTracker {public void track(Object obj){}}&lt;br /&gt;interface Runnable {&lt;br /&gt;    void  run();  //abstract method&lt;br /&gt;    default void run2(){};  //extension method&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;class Tracker extends BaseTracker{&lt;br /&gt;    private String outer_class_var = &quot;&quot;;&lt;br /&gt;&lt;br /&gt;    //anonymous class&lt;br /&gt;    public void track1(final Object event) {&lt;br /&gt;        Executor.execute(new Runnable() {&lt;br /&gt;            //static String a = &quot;&quot;; //ERROR: no static allowed&lt;br /&gt;            final static String b = &quot;&quot;; //constant OK&lt;br /&gt;            String c = outer_class_var;   //compiler create a package-level getter for enclosing class's private variables&lt;br /&gt;&lt;br /&gt;            @Override&lt;br /&gt;            public void run() {&lt;br /&gt;                Tracker.super.track(event);  //Tracker.super refers to enclosing class's super class&lt;br /&gt;                //super.track(event); //ERROR: cannot resolve&lt;br /&gt;                //BaseTracker.track(event);  //ERROR: can only reference static method&lt;br /&gt;            }&lt;br /&gt;        });&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    //local class&lt;br /&gt;    public void track2(final Object event) {&lt;br /&gt;        //anonymous class translated into local class&lt;br /&gt;        class TrackerRunnable implements Runnable {&lt;br /&gt;            //@Override&lt;br /&gt;            public void run(){&lt;br /&gt;                //super need to be in a non-static context&lt;br /&gt;&lt;br /&gt;                System.out.println(this.toString()); //this refers to the TrackerRunnable instance&lt;br /&gt;                System.out.println(super.toString()); //super defaults to the same instance!!!&lt;br /&gt;&lt;br /&gt;                Tracker.super.track(event);  //Tracker.super refers to BaseTracker&lt;br /&gt;                Runnable.super.run2(); //Runnable.super refers to Runnable&lt;br /&gt;&lt;br /&gt;                //super.track(event); //ERROR: cannot resolve, super refers to this&lt;br /&gt;                //BaseTracker.track(event);  //ERROR: can only reference static method, .track() is instance method&lt;br /&gt;            }&lt;br /&gt;        }&lt;br /&gt;        Executor.execute(new TrackerRunnable());&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public static void main(String... args) {&lt;br /&gt;        new Tracker().track2(&quot;&quot;);&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;Reference: &lt;a href=&quot;http://docstore.mik.ua/orelly/java-ent/jnut/ch03_13.htm&quot;&gt;Java in a Nutshell: How Inner Classes Work&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;TODO:  final keyword:&lt;br /&gt;1. class - cannot be subclassed&lt;br /&gt;2. method - cannot be overridden&lt;br /&gt;3. variable - cannot be assigned more than once&lt;br /&gt;Java memory model: stack, heap,&lt;br /&gt;synthetic copy&lt;br /&gt;dp/dip 是个长度单位。  &lt;/div&gt;</content><author><name>Weishi Zeng</name></author><category term="engineering" /><summary type="html">Java Nested Classclass OuterClass { ... static class StaticNestedClass { ... } class InnerClass { ... }}1. Static Nested ClassIntuition:Just like a top level class, nested for packaging convenience.Constructor:OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();Consequences:&amp;nbsp; &amp;nbsp; Enclosing Class Access:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can only direct access outer class static members. (Like any other class accessing OuterClass.java)&amp;nbsp; &amp;nbsp; Members:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can define both static/non-static members. (members: fields + methods.)Usage://like top-level class, more power to define, less power to accessstatic class StaticNestedClass { private Integer instanceField = 1; private static String staticField = outer_static_field; public static void staticMethod() { String a = outer_static_field; } public void instanceMethod() { String a = outer_static_field; //String b = outer_instance_field; //ERROR: cannot reference non-static field }}2. Inner ClassIntuition:Like a instance member, &quot;belongs to&quot; an outer class instance.Constructor:OuterClass.InnerClass innerObject = outerObject.new InnerClass();Consequences:&amp;nbsp; &amp;nbsp; Enclosing Class Access:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Direct access to all outer class members. Just like any method in outer class.&amp;nbsp; &amp;nbsp; Members:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can NOT define any static members. Since it is associated with an instance.Usage://Like a instance member, &quot;belongs to&quot; an outer class instance.class InnerClass { private String inner_instance_field = &quot;inner_instance_field&quot;; public InnerClass () {} public void get_outer_member () { //can access any outer member String a = outer_static_field; String b = outer_private_static_method(); String c = outer_instance_field; inner_instance_field = &quot;&quot;; } //COMPILE ERROR: no static member allowed //public interface inner_interface {}; //an interface is an effective static member //public static String get_static_instance_field () {} //private static String static_field = &quot;static_field&quot;;}2.1. Local ClassIntuition:Defined inside a block (a method, a if block, a for loop). The scope of the class is its enclosing block. A special case of inner class. Thus no static member, a rule inherited from inner class.Constructor: Consequences:&amp;nbsp; &amp;nbsp; Enclosing Class Access:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Direct access to all outer class members. Just like any method in outer class. &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;But for local classes in static contexts, can only refer to static members of the enclosing class. &quot;Non-static member cannot be referenced from a static context&quot; this rule always applies.&amp;nbsp; &amp;nbsp; Members:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can NOT define any static members. EVEN IF it's inside a static block.&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Only exception is for static final String/primitive. As they are stored like a constant. A local class can have static members provided that they are constant variables.(A constant variable is a variable of primitive type or type String that is declaredfinal and initialized with a compile-time constant expression.A compile-time constant expression is typically a string or an arithmetic expressionthat can be evaluated at compile time.Note: If a primitive type or a string is defined as a constant and the value is known atcompile time, the compiler replaces the constant name everywhere in the code with its value.This is called a compile-time constant. If the value of the constant in the outside world changes(for example, if it is legislated that pi actually should be 3.975),you will need to recompile any classes that use this constant to get the current value.&amp;nbsp; &amp;nbsp; Local Variable Access:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can access local variables or method parameters that is final. A local class can use the local variables, method parameters, and even exception parameters that are in its scope, but only if those variables or parameters are declared final. This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined. For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler). The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final.Usage: { class LocalClass { //can access outer member String a = outer_instance_field; String b = outer_static_field; //static String c = &quot;&quot;; //ERROR: no static allowed //final static String d ; //ERROR: not a compile-time constant final static String d = &quot;&quot;; //a constant known at compile time } //static class StaticLocalClass {} //ERROR: local class cannot be static, regardless where.}static { //this is a static context //static class StaticLocalClass {} //ERROR: local class cannot be static, even if in static context class LocalClass { //can access outer member //String a = outer_instance_field; //ERROR: non-static cannot be referenced from static context String b = outer_static_field; //static String c = &quot;&quot;; //ERROR: no static allowed //final static String d ; //ERROR: not a compile-time constant final static String d = &quot;&quot;; //a constant known at compile time }}public void outer_instance_method(Object method_param) { String outer_instance_method_local_var = &quot;&quot;; class LocalClass { //local class at non-static context String f = &quot;&quot;; //can have non-static member /* A local class can have static members provided that they are constant variables. (A constant variable is a variable of primitive type or type String that is declared final and initialized with a compile-time constant expression. A compile-time constant expression is typically a string or an arithmetic expression that can be evaluated at compile time. Note: If a primitive type or a string is defined as a constant and the value is known at compile time, the compiler replaces the constant name everywhere in the code with its value. This is called a compile-time constant. If the value of the constant in the outside world changes (for example, if it is legislated that pi actually should be 3.975), you will need to recompile any classes that use this constant to get the current value. */ //final static Object d = new NestedClassTest(); //ERROR: this is not a compile time constant final static int e = 5; //need to be string or int. need to know it at compile time String a = outer_instance_field; String b = outer_static_field; String c = outer_instance_method_local_var; //outer_instance_method_local_var need to be final Object abc = method_param; //can access final method param private void local_method() { Object d = method_param; //can access final method param //outer_instance_method_local_var = &quot;&quot;; //ERROR: need to be final //method_param = &quot;&quot;; //ERROR: need to be final outer_instance_field = &quot;&quot;; //no problem interact with outer class field outer_static_field = &quot;&quot;; //can access static or non-static LocalClass a = new LocalClass(); } } //a local class is valid only within the scope defined by its enclosing block. //But the local class has access to outer class members. LocalClass a = new LocalClass(); /* A local class can use the local variables, method parameters, and even exception parameters that are in its scope, but only if those variables or parameters are declared final. This is because the lifetime of an instance of a local class can be much longer than the execution of the method in which the class is defined. For this reason, a local class must have a private internal copy of all local variables it uses (these copies are automatically generated by the compiler). The only way to ensure that the local variable and the private copy are always the same is to insist that the local variable is final. */ outer_static_field2 = a; //here, a local class instance outlives local method scope a.local_method();}2.2. Anonymous ClassIntuition:&amp;nbsp;&amp;nbsp;Local class without a name.Constructor://implementing interfacenew InterfacName () { /*class-body*/ }//extending classnew ClassName ( [ argument-list ] ) { /*class-body*/ }Consequences: &amp;nbsp; &amp;nbsp;&amp;nbsp; &amp;nbsp; Enclosing Class Access:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Direct access to all outer class members. Just like local class. &amp;nbsp; &amp;nbsp; Members:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can NOT define any static members. &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Only exception is for static final String/primitive. As they are stored like a constant. &amp;nbsp; &amp;nbsp; Local Variable Access:&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Can access local variables or method parameters that is final. Usage: class Executor {public static void execute(Runnable r){r.run();r.run2();}}class BaseTracker {public void track(Object obj){}}interface Runnable { void run(); //abstract method default void run2(){}; //extension method}class Tracker extends BaseTracker{ private String outer_class_var = &quot;&quot;; //anonymous class public void track1(final Object event) { Executor.execute(new Runnable() { //static String a = &quot;&quot;; //ERROR: no static allowed final static String b = &quot;&quot;; //constant OK String c = outer_class_var; //compiler create a package-level getter for enclosing class's private variables @Override public void run() { Tracker.super.track(event); //Tracker.super refers to enclosing class's super class //super.track(event); //ERROR: cannot resolve //BaseTracker.track(event); //ERROR: can only reference static method } }); } //local class public void track2(final Object event) { //anonymous class translated into local class class TrackerRunnable implements Runnable { //@Override public void run(){ //super need to be in a non-static context System.out.println(this.toString()); //this refers to the TrackerRunnable instance System.out.println(super.toString()); //super defaults to the same instance!!! Tracker.super.track(event); //Tracker.super refers to BaseTracker Runnable.super.run2(); //Runnable.super refers to Runnable //super.track(event); //ERROR: cannot resolve, super refers to this //BaseTracker.track(event); //ERROR: can only reference static method, .track() is instance method } } Executor.execute(new TrackerRunnable()); } public static void main(String... args) { new Tracker().track2(&quot;&quot;); }}Reference: Java in a Nutshell: How Inner Classes WorkTODO: final keyword:1. class - cannot be subclassed2. method - cannot be overridden3. variable - cannot be assigned more than onceJava memory model: stack, heap,synthetic copydp/dip 是个长度单位。</summary></entry><entry><title type="html">Syntax Highlighter With Blogger</title><link href="http://localhost:8888/2016/07/21/function-foo-syntaxhighlighter.html" rel="alternate" type="text/html" title="Syntax Highlighter With Blogger" /><published>2016-07-21T14:24:00-07:00</published><updated>2016-07-21T14:24:00-07:00</updated><id>http://localhost:8888/2016/07/21/function-foo-syntaxhighlighter</id><content type="html" xml:base="http://localhost:8888/2016/07/21/function-foo-syntaxhighlighter.html">&lt;script src=&quot;https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert&quot;&gt;&lt;/script&gt;

&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;Previously I've been using SyntaxHighlighter by Alex Gorbatchev. It needs too much javascript configuration on blogger and hard to change styles.&lt;br /&gt;&lt;br /&gt;One alternative is github gist. However for every code snippet you need to create a gist on github. Thus code and blog are maintained separately. Do I really need the code snippet to be so formal, correct and version controlled? No.&lt;br /&gt;&lt;br /&gt;After a couple hours research, google's code prettify stands out. (&lt;span class=&quot;info&quot;&gt;https://github.com/google/code-prettify&lt;/span&gt;)&lt;br /&gt;Simply adding a &lt;span class=&quot;info&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt; tag in html head, and enclosing code with &lt;span class=&quot;info&quot;&gt;&amp;lt;pre&amp;gt;&lt;/span&gt; would do the job.    &lt;br /&gt;&lt;pre class=&quot;prettyprint linenums&quot;&gt;/**&lt;br /&gt; * pretty print&lt;br /&gt; */&lt;br /&gt;function foo()&lt;br /&gt;{&lt;br /&gt;  if (counter &amp;lt;= 10)&lt;br /&gt;    return;&lt;br /&gt;    // it works!&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;h2 style=&quot;text-align: left;&quot;&gt;How-To Guide&lt;/h2&gt;&lt;div&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;1. Blogger dashboard -&amp;gt; Theme -&amp;gt; Edit HTML&lt;/h4&gt;Add following line.&lt;br /&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&amp;lt;script src=&quot;https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=desert&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/pre&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;2. Blogger dashboard -&amp;gt; Theme -&amp;gt; Customize -&amp;gt; Advanced -&amp;gt; Add CSS&lt;/h4&gt;Add following css.&lt;br /&gt;&lt;pre class=&quot;prettyprint lang-css&quot;&gt;.info {&lt;br /&gt;  background-color:#EEEEEE;&lt;br /&gt;  font-family:Consolas,&quot;Courier New&quot;,Monaco,&quot;Lucida Console&quot;,&quot;Liberation Mono&quot;,&quot;DejaVu Sans Mono&quot;,&quot;Bitstream Vera Sans Mono&quot;;&lt;br /&gt;  font-style: italic;&lt;br /&gt;}&lt;br /&gt;pre.prettyprint{&lt;br /&gt;  width: auto;&lt;br /&gt;  overflow: auto;&lt;br /&gt;  padding: 10px; &lt;br /&gt;}&lt;/pre&gt;&lt;h4 style=&quot;text-align: left;&quot;&gt;3. Use info and prettyprint classes in blog post&lt;/h4&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&amp;lt;span class=&quot;info&quot;&amp;gt;info&amp;lt;span&amp;gt;&lt;/pre&gt;&lt;pre class=&quot;prettyprint&quot;&gt;&amp;lt;pre class=&quot;prettyprint&quot;&amp;gt;code&amp;lt;/pre&amp;gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;h2 style=&quot;text-align: left;&quot;&gt;Lessons Learned&lt;/h2&gt;Writing in html is not an easy job. You need to remember escaping all html syntax.&lt;br /&gt;For example, &lt;span class=&quot;info&quot;&gt;&quot;adding a &amp;lt;script&amp;gt; tag in html&quot;&lt;/span&gt; in html writing needs to be &lt;span class=&quot;info&quot;&gt;&quot;adding a &amp;amp;lt;script&amp;amp;gt; tag in html&quot;&lt;/span&gt;. Otherwise it would complain you don't have a enclosing &lt;span class=&quot;info&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt; tag.&lt;br /&gt;&lt;br /&gt;Also, there are two ways of displaying an html entity. (&lt;a href=&quot;https://www.w3schools.com/HTML/html_entities.asp&quot;&gt;w3schools&lt;/a&gt;)&lt;br /&gt;&lt;pre class=&quot;info&quot;&gt;&amp;amp;entity_name;&lt;br /&gt;  OR&lt;br /&gt;&amp;amp;#entity_number;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;So a less than sign (&amp;lt;) can be either &amp;amp;lt; or &amp;amp;#60;  &lt;/div&gt;</content><author><name>Weishi Zeng</name></author><category term="engineering" /><summary type="html"></summary></entry><entry><title type="html">Wildcard and Type Parameter - ? extends Number</title><link href="http://localhost:8888/2016/07/19/wildcard-and-type-parameter.html" rel="alternate" type="text/html" title="Wildcard and Type Parameter - ? extends Number" /><published>2016-07-19T16:24:00-07:00</published><updated>2016-07-19T16:24:00-07:00</updated><id>http://localhost:8888/2016/07/19/wildcard-and-type-parameter</id><content type="html" xml:base="http://localhost:8888/2016/07/19/wildcard-and-type-parameter.html">&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;&lt;pre style=&quot;background-color: white;&quot;&gt;&lt;pre style=&quot;font-family: Menlo; font-size: 9pt;&quot;&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;script src=&quot;https://gist.github.com/WeishiZeng/1bfc6e169ce466028553054a4adeb95b.js&quot;&gt;&lt;/script&gt;So,&lt;br /&gt;&lt;b&gt;Integer&lt;/b&gt; subclassed &lt;b&gt;Number&lt;/b&gt;, but &lt;b&gt;List&amp;lt;Integer&amp;gt;&lt;/b&gt;&lt;integer&gt; is treated as a different class as to &lt;b&gt;List&amp;lt;Number&amp;gt;.&amp;nbsp;&lt;/b&gt;&lt;/integer&gt;&lt;br /&gt;&lt;integer&gt;&lt;number&gt;Thus the following &quot;? extends&quot; is required in&lt;/number&gt;&lt;/integer&gt;&lt;br /&gt;&lt;integer&gt;&lt;number&gt;&lt;br /&gt;&lt;/number&gt;&lt;/integer&gt;sumOfList(List&amp;lt;? extends Number&amp;gt; list)&lt;/div&gt;</content><author><name>Weishi Zeng</name></author><summary type="html">So,Integer subclassed Number, but List&amp;lt;Integer&amp;gt; is treated as a different class as to List&amp;lt;Number&amp;gt;.&amp;nbsp;Thus the following &quot;? extends&quot; is required insumOfList(List&amp;lt;? extends Number&amp;gt; list)</summary></entry><entry><title type="html">constructor for abstract class - java</title><link href="http://localhost:8888/2015/01/21/constructor-for-abstract-class-java.html" rel="alternate" type="text/html" title="constructor for abstract class - java" /><published>2015-01-21T15:19:00-08:00</published><updated>2015-01-21T15:19:00-08:00</updated><id>http://localhost:8888/2015/01/21/constructor-for-abstract-class-java</id><content type="html" xml:base="http://localhost:8888/2015/01/21/constructor-for-abstract-class-java.html">&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;I understand an abstract class as a class that cannot be instantiated.&lt;br /&gt;Then why can it have a constructor?&lt;br /&gt;&lt;br /&gt;1. the constructor should be protected. (public is useless since it's not gonna be instantiated. can only be called by subclasses' super())&lt;br /&gt;2. use it to initialize abstract superclass fields.&lt;br /&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 15px; line-height: 19.5px;&quot;&gt;&quot;In any case, don't forget that if you don't define a constructor, then the compiler will automatically generate one for you (this one is public, has no argument, and does nothing).&quot;&lt;/span&gt;&lt;br /&gt;&lt;span style=&quot;background-color: white; color: #222222; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 15px; line-height: 19.5px;&quot;&gt;-&lt;/span&gt;&lt;span style=&quot;color: #222222; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&quot;&gt;&lt;span style=&quot;font-size: 15px; line-height: 19.5px;&quot;&gt;http://stackoverflow.com/questions/260666&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&quot;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 13px; line-height: 19.2000007629395px;&quot;&gt;If a constructor does not explicitly invoke a superclass constructor, the Java compiler automatically inserts a call to the no-argument constructor of the superclass. If the super class does not have a no-argument constructor, you will get a compile-time error.&amp;nbsp;&lt;/span&gt;&lt;code style=&quot;font-family: Monaco, Courier, 'Courier New'; font-size: 13px; line-height: 19.2000007629395px;&quot;&gt;Object&lt;/code&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 13px; line-height: 19.2000007629395px;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;i style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 13px; line-height: 19.2000007629395px;&quot;&gt;does&lt;/i&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 13px; line-height: 19.2000007629395px;&quot;&gt;&amp;nbsp;have such a constructor, so if&amp;nbsp;&lt;/span&gt;&lt;code style=&quot;font-family: Monaco, Courier, 'Courier New'; font-size: 13px; line-height: 19.2000007629395px;&quot;&gt;Object&lt;/code&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif; font-size: 13px; line-height: 19.2000007629395px;&quot;&gt;&amp;nbsp;is the only superclass, there is no problem.&lt;/span&gt;&quot; -http://docs.oracle.com/javase/tutorial/java/IandI/super.html&lt;/div&gt;</content><author><name>Weishi Zeng</name></author><summary type="html">I understand an abstract class as a class that cannot be instantiated.Then why can it have a constructor?1. the constructor should be protected. (public is useless since it's not gonna be instantiated. can only be called by subclasses' super())2. use it to initialize abstract superclass fields.&quot;In any case, don't forget that if you don't define a constructor, then the compiler will automatically generate one for you (this one is public, has no argument, and does nothing).&quot;-http://stackoverflow.com/questions/260666&quot;If a constructor does not explicitly invoke a superclass constructor, the Java compiler automatically inserts a call to the no-argument constructor of the superclass. If the super class does not have a no-argument constructor, you will get a compile-time error.&amp;nbsp;Object&amp;nbsp;does&amp;nbsp;have such a constructor, so if&amp;nbsp;Object&amp;nbsp;is the only superclass, there is no problem.&quot; -http://docs.oracle.com/javase/tutorial/java/IandI/super.html</summary></entry><entry><title type="html">Polymorphism, variable shadowing/hiding</title><link href="http://localhost:8888/2015/01/20/polymorphism-variable-shadowing.html" rel="alternate" type="text/html" title="Polymorphism, variable shadowing/hiding" /><published>2015-01-20T16:59:00-08:00</published><updated>2015-01-20T16:59:00-08:00</updated><id>http://localhost:8888/2015/01/20/polymorphism-variable-shadowing</id><content type="html" xml:base="http://localhost:8888/2015/01/20/polymorphism-variable-shadowing.html">&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;&lt;div&gt;&lt;span style=&quot;color: #222222; font-family: Helvetica Neue, Helvetica, Arial, sans-serif;&quot;&gt;&lt;span style=&quot;background-color: white; font-size: 13px; line-height: 17.5499992370605px;&quot;&gt;Let's say if superclass and subclass have one instance field named the same - var. Then casting the object will change the result. &quot;((Superclass) subclassObj).var&quot; gives the Superclass's instance field var. So I suppose variable names in Java are resolved by the reference type, not the actual obj type they are referencing. while method names are dynamic binding, which uses the actual obj type. So it comes the polymorphism&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Weishi Zeng</name></author><summary type="html">Let's say if superclass and subclass have one instance field named the same - var. Then casting the object will change the result. &quot;((Superclass) subclassObj).var&quot; gives the Superclass's instance field var. So I suppose variable names in Java are resolved by the reference type, not the actual obj type they are referencing. while method names are dynamic binding, which uses the actual obj type. So it comes the polymorphism</summary></entry><entry><title type="html">JAVA - System.currentTimeMillis()</title><link href="http://localhost:8888/2014/09/24/java-systemcurrenttimemillis.html" rel="alternate" type="text/html" title="JAVA - System.currentTimeMillis()" /><published>2014-09-24T10:47:00-07:00</published><updated>2014-09-24T10:47:00-07:00</updated><id>http://localhost:8888/2014/09/24/java-systemcurrenttimemillis</id><content type="html" xml:base="http://localhost:8888/2014/09/24/java-systemcurrenttimemillis.html">&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;Today, when I was trying to generate a series of random number in java code to be an database primary key, I was thinking of&lt;br /&gt;System.currentTimeMillis()&lt;br /&gt;&lt;br /&gt;However, it doesn't work as the granularity is actually dependent on the OS. It might be 10 times miliseconds. Anyway, in my for loop it some times give duplicate value.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;Also, I find an interesting utility in Eclipse. Let's talk about jpage next time.&lt;/div&gt;</content><author><name>Weishi Zeng</name></author><summary type="html">Today, when I was trying to generate a series of random number in java code to be an database primary key, I was thinking ofSystem.currentTimeMillis()However, it doesn't work as the granularity is actually dependent on the OS. It might be 10 times miliseconds. Anyway, in my for loop it some times give duplicate value.Also, I find an interesting utility in Eclipse. Let's talk about jpage next time.</summary></entry><entry><title type="html">i = i++</title><link href="http://localhost:8888/2013/12/20/i-i.html" rel="alternate" type="text/html" title="i = i++ " /><published>2013-12-20T19:26:00-08:00</published><updated>2013-12-20T19:26:00-08:00</updated><id>http://localhost:8888/2013/12/20/i-i</id><content type="html" xml:base="http://localhost:8888/2013/12/20/i-i.html">&lt;div dir=&quot;ltr&quot; style=&quot;text-align: left;&quot; trbidi=&quot;on&quot;&gt;&lt;b style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot;&gt;The code&lt;/b&gt;&lt;span style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot;&gt;&lt;/span&gt;&lt;br /&gt;&lt;pre style=&quot;background-color: #faf7f1; font-size: 16px;&quot;&gt;&lt;b&gt;int i = 0;&lt;/b&gt;&lt;br /&gt;&lt;b&gt;i = i++;&lt;/b&gt;&lt;br /&gt;&lt;b&gt;System.out.println(i);&lt;/b&gt;&lt;/pre&gt;&lt;b style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot;&gt;produces the output &quot;0&quot; instead of &quot;1&quot;. Why?&lt;/b&gt;&lt;span style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot;&gt;&lt;/span&gt;&lt;br /&gt;&lt;div style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot;&gt;&lt;br clear=&quot;all&quot; /&gt;&lt;/div&gt;&lt;hr style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot; /&gt;&lt;div style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot;&gt;Let's take a close look at what the line &quot;i = i++;&quot; does:&lt;/div&gt;&lt;div style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot;&gt;&lt;/div&gt;&lt;ol style=&quot;background-color: #faf7f1; font-family: Arial, Helvetica, sans-serif; font-size: 16px;&quot;&gt;&lt;li&gt;&quot;i++&quot; is evaluated. The value of &quot;i++&quot; is the value of i before the increment happens.&lt;/li&gt;&lt;li&gt;As part of the evaluation of &quot;i++&quot;, i is incremented by one. Now i has the value of 1;&lt;/li&gt;&lt;li&gt;The assignment is executed. i is assigned the value of &quot;i++&quot;, which is the value of i&amp;nbsp;&lt;i&gt;before&lt;/i&gt;&amp;nbsp;the increment - that is, 0.&lt;/li&gt;&lt;/ol&gt;&lt;div&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;&lt;br /&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;Source:&amp;nbsp;&lt;/span&gt;&lt;a href=&quot;http://www.coderanch.com/how-to/java/PostIncrementOperatorAndAssignment&quot;&gt;http://www.coderanch.com/how-to/java/PostIncrementOperatorAndAssignment&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Weishi Zeng</name></author><summary type="html">The codeint i = 0;i = i++;System.out.println(i);produces the output &quot;0&quot; instead of &quot;1&quot;. Why?Let's take a close look at what the line &quot;i = i++;&quot; does:&quot;i++&quot; is evaluated. The value of &quot;i++&quot; is the value of i before the increment happens.As part of the evaluation of &quot;i++&quot;, i is incremented by one. Now i has the value of 1;The assignment is executed. i is assigned the value of &quot;i++&quot;, which is the value of i&amp;nbsp;before&amp;nbsp;the increment - that is, 0.Source:&amp;nbsp;http://www.coderanch.com/how-to/java/PostIncrementOperatorAndAssignment</summary></entry></feed>